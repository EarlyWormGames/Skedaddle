<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skedaddle: Aim IK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lorisicon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Skedaddle
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page1.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Aim IK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AimIK solver is a modification of the CCD algorithm that rotates a hierarchy of bones to make a child Transform of that hierarchy aim at a target. It differs from the basic built-in Animator.SetLookAtPosition or the LookAtIK functionality, because it is able to accurately aim transforms that are not aligned to the main axis of the hierarchy.</p>
<p>AimIK can produce very stabile and natural looking retargeting of character animation, it hence has great potential for use in weapon aiming systems. With AimIK we are able to offset a single forward aiming pose or animation to aim at targets even almost behind the character. It is only the Quaternion singularity point at 180 degrees offset, where the solver can not know which way to turn the spine. Just like LookAtIK, AimIK provides a clampWeight property to avoid problems with that singularity issue.</p>
<p>AimIK also works with rotation limits, however it is more prone to get jammed than other constrained solvers, should the chain be heavily constrained.</p>
<p>Aim provides high accuracy at a very good speed, still it is necessary to keep in mind to maintain the target position at a safe distance from the aiming Transform. If distance to the target position is less than distance to the aiming Transform, the solver will try to roll in on itself and might be unable to produce a finite result.</p>
<div class="image">
<img src="AimIK.png" alt="AimIK.png"/>
<div class="caption">
The AimIK solver in action</div></div>
<p> <b>Getting started:</b></p><ul>
<li>Set up your character's Animator/Animation to play an aiming forward animation/pose</li>
<li>Add the AimIK component to your character</li>
<li>Assign the spine bones to "Bones" in the component, one by one in descending order (parents first).</li>
<li>Assign the Aim Transform (the Transform that you want to aim at the target). It could be the gun, the hand bone or just an empty game object parented to the hand</li>
<li>Make sure Axis represents the local axis of the Aim Transform that you want to be aimed at the target. For example if the blue (z) axis of a gun is pointing towards it's barrel, you will need to set Axis to (0, 0, 1).</li>
<li>Set weight to 1, press Play</li>
<li>Move the target handle around in Scene View to see how AimIK behaves</li>
</ul>
<p><b>Component variables:</b></p><ul>
<li><b>timeStep</b> - if zero, will update the solver in every LateUpdate(). Use this for chains that are animated. If &gt; 0, will be used as updating frequency so that the solver will reach its target in the same time on all machines</li>
<li><b>fixTransforms</b> - if true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance</li>
</ul>
<p><b>Solver variables:</b></p><ul>
<li><b>target</b> - the target Transform. If assigned, solver IKPosition will be automatically set to the position of the target.</li>
<li><b>poleTarget</b> - if assigned, will automatically set polePosition to the position of this Transform. IKSolverAim.polePosition keeps another axis (poleAxis) of the Aim Transform oriented towards IKSolverAim.polePosition.</li>
<li><b>transform</b> - (Aim Transform) the Transform that we want to aim at the IKPosition (usually the gun or the flashlight, represented as the pink cone on the image above).</li>
<li><b>axis</b> - the local axis of the Aim Transform that you want to be aimed at the IKPosition. For example if the blue (z) axis of a gun is pointing towards it's barrel, you will need to set Axis to (0, 0, 1).</li>
<li><b>poleAxis</b> - the local axis of the Aim Transform that you want to keep oriented towards IKSolverAim.polePosition</li>
<li><b>weight</b> - the solver weight for smoothly blending out the effect of the IK</li>
<li><b>poleWeight</b> - the weight of keeping the poleAxis of the AimTransform oriented towards polePosition.</li>
<li><b>tolerance</b> - minimum offset from last reached angle. Will stop solving if difference from previous reached angle is less than tolerance. If tolerance is zero, will iterate until maxIterations.</li>
<li><b>maxIterations</b> - max iterations per frame. If tolerance is 0, will always iterate until maxIterations</li>
<li><b>clampWeight</b> - clamping rotation of the solver. 0 is free rotation, 1 is completely clamped to zero effect</li>
<li><b>clampSmoothing</b> - the number of sine smoothing iterations applied to clamping to make it smoother.</li>
<li><b>bones</b> - bones used by the solver to orient the Aim Transform to the target. All bones need to be direct ancestors of the Aim Transform and sorted in descending order. You can skip bones in the hierarchy and the Aim Transform itself can also be included. The bone hierarchy can not be branched, meaning you cant assing bones from both hands. Bone weight determines how strongly it is used in bending the hierarchy</li>
</ul>
<div class="image">
<img src="AimIKComponent.png" alt="AimIKComponent.png"/>
</div>
<p><b>Script References:</b></p><ul>
<li><a href="http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_i_k_solver_aim.html">Solver </a></li>
<li><a href="http://www.root-motion.com/finalikdox/html/class_root_motion_1_1_final_i_k_1_1_aim_i_k.html">Component</a></li>
</ul>
<p><b>Changing the aiming target:</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> AimIK aimIK;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    aimIK.solver.IKPosition = something;</div><div class="line">}</div></div><!-- fragment --><p><b>Using the Pole:</b></p>
<p>The polePosition can be helpful when making weapon aiming setups. Let's say we have a gun that's local Z axis is facing towards it's barrel and local Y axis is facing up. In this case we have to set AimIK "Axis" to (0, 0, 1) and "Pole Axis" to (0, 1, 0). If we now play the scene and set "Weight" and "Pole Weight" to 1, we will have 2 handles, one for the aiming target and the other for twisting the gun and the body of the character.</p>
<p>Adjusting the Pole by script:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> AimIK aimIK;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    aimIK.solver.polePosition = something;</div><div class="line">    aimIK.solver.poleWeight = 1f;</div><div class="line">}</div></div><!-- fragment --><p><b>Changing the Aim Transform:</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> AimIK aimIK;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    aimIK.solver.transform = something;</div><div class="line">    aimIK.solver.axis = localAxisOfTheTransformToAimAtTheTarget;</div><div class="line">}</div></div><!-- fragment --><p><b>Adding AimIK in runtime:</b></p><ul>
<li>Add the AimIK component via script</li>
<li>Call AimIK.solver.SetChain()</li>
</ul>
<p><b>Changing AimIK bone hierarchy in runtime:</b> </p><div class="fragment"><div class="line"><span class="keyword">public</span> AimIK aimIK;</div><div class="line"></div><div class="line"><span class="keyword">public</span> Transform[] newBones;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Change() {</div><div class="line">    aimIK.solver.SetChain(newBones, aim.transform);</div><div class="line">}</div></div><!-- fragment --><p><b>Using AimIK with Rotation Limits:</b> <br />
 It is sometimes necessary to limit the effect of AimIK on one of the bones in it's chain. Usually when you wish to use the elbow joint in the process of aiming a single handed weapon or when you wish to limit the rotation of a spine bone to twisting only. If you just added the RotationLimit component to the bone, it would also interfere with the animation (keep the spine stiff), not just the IK. You can make the RotationLimit only have an effect on the AimIK by defaulting it's rotation each frame before AimIK solves:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> AimIK aimIK;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate() {</div><div class="line">    <span class="comment">// Set current animated localRotation as default local rotation for the rotation limits so they will not interfere with the animation, but only the IK</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; aimIK.solver.bones.Length; i++) {</div><div class="line">        <span class="keywordflow">if</span> (aimIK.solver.bones[i].rotationLimit != null) {</div><div class="line">            aimIK.solver.bones[i].rotationLimit.SetDefaultLocalRotation();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Please note that each RotationLimit decreases the probability of the solver smoothly reaching it's target. <br />
 Since FinalIK 0.4 introduced the polePosition and poleWeight, using Rotation Limits on characters can in most cases be avoided by using the pole to keep the body upright.</p>
<p><b>Bone weights</b> <br />
 Each bone in the "Bones" has a weight parameter. It determines how much proportionally is a bone used in the solving process. Fox example if you do not wish a certain spine bone to bend too much, you can just decrease it's weight.</p>
<p><b>Aiming 2-handed weapons:</b> <br />
 When aiming 2-handed weapons, we can use only the spine bones (common parents for both hands) in the AimIK bone hierarchy. If we used the arm bones, the other hand would loose contact with the object. Sometimes using just the spine bones is not enough though, as the spine would bend exessively and the character would end up in unnatural poses. We can solve this problem, by adding some of the arm bones (the arm that is holding the object) to AimIK and then use FullBodyBipedIK or LimbIK to put the other hand back on its place after AimIK is done. Take a look at this <a href="https://www.youtube.com/watch?v=5DlTjasmTLk">tutorial video</a> to see how it could be done.</p>
<p><b>Redirecting animation:</b> <br />
 AimIK is perfect for keeping objects steadily aimed at the target. Sometimes those objects have a lot of swinging motion in the animation, like swinging a sword for example, and it is not good to use AimIK to keep the sword oriented at a certain position during that swing. It would keep the sword orientation fixed by bending the rest of the hierarchy and that would interfere with the animation in an unwanted way. It is still possible to use AimIK to redirect swinging animations like swordplay or punching, take a look at this <a href="https://www.youtube.com/watch?v=OhCtiV5r8HA">tutorial video</a> to see how it could be done.</p>
<p><b>Recoil/reload animations while aiming:</b> <br />
 While AimIK weight is 1, the solver will maintain the weapon oriented at the target at all times. This might not be the desired behaviour while playing a recoil or reloading animation. We can dynamically change the Axis of AimIK to overcome this issue.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LateUpdate() {</div><div class="line">        aimIK.solver.axis = aimIK.solver.transform.InverseTransformDirection(character.forward);</div><div class="line">}</div></div><!-- fragment --><p>That line is telling AimIK that whatever the direction of the weapon in the animation, it is the default forward aiming direction. "Character.forward" is the direction that the weapon is aimed at (keep it in character space so the effect rotates with the character) in the normal aiming animation without any recoil, so If you were currently playing an "aim right" animation, you should set it to "character.right" instead. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
