<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Skedaddle: Full Body Biped IK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="lorisicon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Skedaddle
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page6.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Full Body Biped IK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Final IK includes an extremely flexible and powerful high speed lightweight FBIK solver for biped characters.</p>
<p>FullBodyBipedIK maps any biped character to a low resolution multi-effector IK rig, solves it, and maps the result back to the character. This is done each frame in LateUpdate, after Mecanim/Legacy is done animating, so it is completely independent from the animating system.</p>
<p><b>Chains:</b> Internally, each limb and the body are instances of the FBIKChain class. The root chain is the body, consisting of a single node, and the limbs are it's children. This setup forms the multi-effector IK tree around the root node.</p>
<p><b>Nodes:</b> Nodes are members of the Chains. For instance, an Arm chain contains three nodes - upper arm, forearm and the hand. Each node maintains a reference to it's bone (node.transform). When the solver is processing or has finished, the solved position of the bone is stored in node.solverPosition.</p>
<p><b>Effectors:</b> FullBodyBipedIK has three types of effectors - end-effectors (hands and feet), mid-body effectors (shoulders and thighs) and multi-effectors (the body). End-effectors can be rotated while changing the rotation of mid-body and multi-effectors has no effect. Changing end-effector rotation also changes the bending direction of the limb (unless you are using bend goals to override it). The body effector is a multi-effector, meaning it also drags along both thigh effectors (to simplify positioning of the body). Effectors also have the positionOffset property that can be used to very easily manupulate with the underlaying animation. Effectors will reset their positionOffset to Vector3.zero after each solver update.</p>
<p><b>Pulling, Reaching and Pushing:</b> Each chain has the "pull" property. When all chains have pull equal to 1, pull weight is distributed equally between the limbs. That means reaching all effectors is not quaranteed if they are very far from each other. The result can be adjusted or improved by changing the "reach" parameter of the chain, increasing the solver iteration count or updating the solver more than once per frame. However, when for instance the left arm chain has pull weight equal to 1 and all others have 0, you can pull the character from it's left hand to Infinity without losing contact. The Push and Push Parent values determine how much a limb transfers energy to it's parent nodes when the target is in reach. Experiment with those values in the Scene view to get a better understanding of how they behave.</p>
<p><b>Mapping:</b> IKSolverFullBodyBiped solves a very low resolution high speed armature. Your character probably has a lot more bones in it's spine though, it might have twist bones in the arms and shoulder or hip bones and so on. Therefore, the solver needs to map the high resolution skeleton to the low resolution solver skeleton before solving and vice versa after the solver has finished. There are 3 types of mappers - IKMappingSpine for mapping the pelvis and the spine, IKMappingLimb for the limbs (including the clavicle) and IKMappingBone for the head. You can access them through IKSolverFullBody.spineMapping, IKSolverFullBody.limbMappings and IKSolverFullBody.boneMappings</p>
<div class="image">
<img src="FullBodyBipedIK.png" alt="FullBodyBipedIK.png"/>
<div class="caption">
Retargeting a single punching animation with FullBodyBipedIK</div></div>
<p> <b>Limitations:</b></p><ul>
<li>FullBodyBipedIK does not have effectors for the fingers and toes. Solving fingers with IK would be an overkill in most cases as there are only so few poses for the hands in a game. Using 10 4-segment constrained CCD or FABRIK chains to position the fingers however is probably something you don't want to waste your precious milliseconds on. See the Driving Rig demo to get an idea how to very quickly (and entirely in Unity) pose the fingers to an object.</li>
<li>FullBodyBipedIK samples the initial pose of your character (in Start() and each time you re-initiate the solver) to find out which way the limbs should be bent. Hence the limitation - the limbs of the character at that moment should be bent in their natural directions. Some characters however are in geometrically perfect T-Pose, meaning their limbs are completely straight. Some characters even have their limbs bent slightly in the inverse direction (some Mixamo rigs for example). FullBodyBipedIK will alarm you should this problem occur. All you will have to do, is rotate the forearm or calf bones in the Scene view slightly in the direction they should be bent. Since those rotations will be overwritten in play mode by animation anyway, you should not be afraid of messing up your character.</li>
<li>FullBodyBipedIK does not have elbow/knee effectors. That might change in the future should there be a practical demand for them. Elbow and knee positions can still be modified though as bend goals are supported.</li>
<li>Optimize Game Objects should be disabled or at least all the bones needed by the solver (FullBodyBipedIK.references) exposed.</li>
<li>Additional bones in the limbs are supported as long as their animation is twisting only. If the additional bones have swing animation, like for example wing bones, FBBIK will not solve the limb correctly.</li>
<li>FullBodyBipedIK does not rotate the shoulder bone when the character is pulled by the hand. It will maintain the shoulder bone rotation relative to the chest as it is in the animation. In most cases, it is not a problem, but sometimes, especially when reaching for something above the head, having the shoulder bone rotate along would make it more realistic. In this case you should either have an underlaying reach up (procedural) animation that rotates the shoulder bone or it can also be rotated via script before the IK solver reads the character's pose. There is also a workaround script included in the demos, called ShoulderRotator, just add it to the FBBIK game object.</li>
<li>When you move a limb end-effector and the effector rotation weight is 0, FBBIK will try to maintain the bending direction of the limb as it is animated. When the limb rotates close to 180 degrees from it's animated direction, you will start experiencing rolling of the limb, meaning, the solver has no way to know at this point of singularity, which way to rotate the limb. Therefore if you for example have a walking animation, where the hands are down and you want to use IK to grab something from directly above the head, you will have to take the inconvenience to also animate the effector rotation or use a bend goal, to make sure the arm does not roll backwards when close to 180 degrees of angular offset. This is not a bug, it is a logical inevitability if we want to maintain the animated bending direction by default.</li>
<li>FullBodyBipedIK considers all elbows and knees as 3 DOF joints with swing rotation constrained to the range of a hemisphere (Since 0.22, used to be 1 DOF). That allows for full accuracy mapping of all biped rigs, the only known limitation is that the limbs can't be inverted (broken from the knee/elbow).</li>
</ul>
<p><b>Getting started:</b></p><ul>
<li>Add the FullBodyBipedIK component to the root of your character (the same GameObject that has the Animator/Animation component)</li>
<li>Make sure the auto-detected biped references are correct</li>
<li>Make sure the Root Node was correctly detected. It should be one of the bones in the lower spine.</li>
<li>Take a look at the character in the scene view, make sure you see the FullBodyBipedIK armature on top the character.</li>
<li>Press Play, weigh in the effectors</li>
</ul>
<p><b>Accessing the Effectors:</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> FullBodyBipedIK ik;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    ik.solver.leftHandEffector.position = something; <span class="comment">// Set the left hand effector position to a point in world space. This has no effect if the effector&#39;s positionWeight is 0.</span></div><div class="line">    ik.solver.leftHandEffector.rotation = something; <span class="comment">// Set the left hand effector rotation to a point in world space. This has no effect if the effector&#39;s rotationWeight is 0.</span></div><div class="line">    ik.solver.leftHandEffector.positionWeight = 1f; <span class="comment">// Weighing in the effector position, the left hand will be pinned to ik.solver.leftHandEffector.position.</span></div><div class="line"></div><div class="line">    <span class="comment">// Weighing in the effector rotation, the left hand and the arm will be pinned to ik.solver.leftHandEffector.rotation.</span></div><div class="line">    <span class="comment">// Note that if you only wanted to rotate the hand, but not change the arm bending, </span></div><div class="line">    <span class="comment">// it is better to just rotate the hand bone after FBBIK has finished updating (use the OnPostUpdate delegate).</span></div><div class="line">    ik.solver.leftHandEffector.rotationWeight = 1f;</div><div class="line"></div><div class="line">    <span class="comment">// Offsets the hand from it&#39;s animated position. If effector positionWeight is 1, this has no effect.</span></div><div class="line">    <span class="comment">// Note that the effectors will reset their positionOffset to Vector3.zero after each update, so you can (and should) use them additively. </span></div><div class="line">    <span class="comment">//This enables you to easily edit the value by more than one script.</span></div><div class="line">    ik.solver.leftHandEffector.positionOffset += something; </div><div class="line">    </div><div class="line">    <span class="comment">//The effector mode is for changing the way the limb behaves when not weighed in.</span></div><div class="line">    <span class="comment">//Free means the node is completely at the mercy of the solver. </span></div><div class="line">    <span class="comment">//(If you have problems with smoothness, try changing the effector mode of the hands to MaintainAnimatedPosition or MaintainRelativePosition</span></div><div class="line"></div><div class="line">    <span class="comment">//MaintainAnimatedPosition resets the node to the bone&#39;s animated position in each internal solver iteration. </span></div><div class="line">    <span class="comment">//This is most useful for the feet, because normally you need them where they are animated.</span></div><div class="line"></div><div class="line">    <span class="comment">//MaintainRelativePositionWeight maintains the limb&#39;s position relative to the chest for the arms and hips for the legs. </span></div><div class="line">    <span class="comment">// So if you pull the character from the left hand, the right arm will rotate along with the chest.</span></div><div class="line">    <span class="comment">//Normally you would not want to use this behaviour for the legs.</span></div><div class="line">    ik.solver.leftHandEffector.maintainRelativePositionWeight = 1f;</div><div class="line"></div><div class="line">    <span class="comment">// The body effector is a multi-effector, meaning it also manipulates with other nodes in the solver, namely the left thigh and the right thigh</span></div><div class="line">    <span class="comment">// so you could move the body effector around and the thigh bones with it. If we set effectChildNodes to false, the thigh nodes will not be changed by the body effector.</span></div><div class="line">    ik.solver.body.effectChildNodes = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Other effectors: rightHandEffector, leftFootEffector, rightFootEffector, leftShoulderEffector, rightShoulderEffector, leftThighEffector, rightThighEffector, bodyEffector</span></div><div class="line"></div><div class="line">    <span class="comment">// You can also find an effector by:</span></div><div class="line">    ik.solver.GetEffector(<a class="code" href="namespace_root_motion_1_1_final_i_k.html#ae0dd2058c7667b6f132c11a6b860c14a">FullBodyBipedEffector</a> effectorType);</div><div class="line">    ik.solver.GetEffector(<a class="code" href="namespace_root_motion_1_1_final_i_k.html#ae8848c0353270a08dcfe8b85a5c9b761">FullBodyBipedChain</a> chainType);</div><div class="line">    ik.solver.GetEndEffector(<a class="code" href="namespace_root_motion_1_1_final_i_k.html#ae8848c0353270a08dcfe8b85a5c9b761">FullBodyBipedChain</a> chainType); <span class="comment">// Returns only hand or feet effectors</span></div><div class="line">}</div></div><!-- fragment --><p><b>Accessing the Chains:</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> FullBodyBipedIK ik;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    ik.solver.leftArmChain.pull = 1f; <span class="comment">// Changing the Pull value of the left arm</span></div><div class="line">    ik.solver.leftArmChain.reach = 0f; <span class="comment">// Changing the Reach value of the left arm</span></div><div class="line"></div><div class="line">    <span class="comment">// Other chains: rightArmChain, leftLegChain, rightLegChain, chain (the root chain)</span></div><div class="line"></div><div class="line">    <span class="comment">// You can also find a chain by:</span></div><div class="line">    ik.solver.GetChain(<a class="code" href="namespace_root_motion_1_1_final_i_k.html#ae8848c0353270a08dcfe8b85a5c9b761">FullBodyBipedChain</a> chainType);</div><div class="line">    ik.solver.GetChain(<a class="code" href="namespace_root_motion_1_1_final_i_k.html#ae0dd2058c7667b6f132c11a6b860c14a">FullBodyBipedEffector</a> effectorType);</div><div class="line">}</div></div><!-- fragment --><p><b>Accessing the Mapping:</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> FullBodyBipedIK ik;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LateUpdate () {</div><div class="line">    ik.solver.spineMapping.iterations = 2; <span class="comment">// Changing the Spine Mapping Iterations</span></div><div class="line">    ik.solver.leftArmMapping.maintainRotationWeight = 1f; <span class="comment">// Make the left hand maintain it&#39;s rotation as animated.</span></div><div class="line">    ik.solver.headMapping.maintainRotationWeight = 1f; <span class="comment">// Make the head maintain it&#39;s rotation as animated.</span></div><div class="line">}</div></div><!-- fragment --><p><b>Adding FullBodyBipedIK in runtime (UMA):</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespace_root_motion.html">RootMotion</a>; <span class="comment">// Need to include the RootMotion namespace as well because of the BipedReferences</span></div><div class="line"></div><div class="line">FullBodyBipedIK ik;</div><div class="line"></div><div class="line"><span class="comment">// Call this method whenever you need in runtime. </span></div><div class="line"><span class="comment">// Please note that FBBIK will sample the pose of the character at initiation so at the time of calling this method,</span></div><div class="line"><span class="comment">// the limbs of the character should be bent in their natural directions.</span></div><div class="line"><span class="keywordtype">void</span> AddFBBIK (GameObject go, BipedReferences references = null) {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (references == null) { <span class="comment">// Auto-detect the biped definition if we don&#39;t have it yet</span></div><div class="line">        BipedReferences.AutoDetectReferences(ref references, go.transform, BipedReferences.AutoDetectParams.Default);</div><div class="line">    }</div><div class="line"></div><div class="line">    ik = go.AddComponent&lt;FullBodyBipedIK&gt;(); <span class="comment">// Adding the component</span></div><div class="line"></div><div class="line">    <span class="comment">// Set the FBBIK to the references. You can leave the second parameter (root node) to null if you trust FBBIK to automatically set it to one of the bones in the spine.</span></div><div class="line">    ik.SetReferences(references, null);</div><div class="line"></div><div class="line">    <span class="comment">// Using pre-defined limb orientations to safeguard from possible pose sampling problems (since 0.22)</span></div><div class="line">    ik.solver.SetLimbOrientations(BipedLimbOrientations.UMA); <span class="comment">// The limb orientations definition for UMA skeletons</span></div><div class="line">    <span class="comment">// or...</span></div><div class="line">    ik.solver.SetLimbOrientations(BipedLimbOrientations.MaxBiped); <span class="comment">// The limb orientations definition for 3ds Max Biped skeletons</span></div><div class="line">    <span class="comment">// or..</span></div><div class="line">    ik.solver.SetLimbOrientations(yourCustomBipedLimbOrientations); <span class="comment">// Your custom limb orientations definition</span></div><div class="line"></div><div class="line">    <span class="comment">// To know how to fill in the custom limb orientations definition, you should imagine your character standing in I-pose (not T-pose) with legs together and hands on the sides...</span></div><div class="line">    <span class="comment">// The Upper Bone Forward Axis is the local axis of the thigh/upper arm bone that is facing towards character forward.</span></div><div class="line">    <span class="comment">// Lower Bone Forward Axis is the local axis of the calf/forearm bone that is facing towards character forward.</span></div><div class="line">    <span class="comment">// Last Bone Left Axis is the local axis of the foot/hand that is facing towards character left.</span></div><div class="line">}</div></div><!-- fragment --><p><b>Solving the head</b> <br />
 Final IK 0.5 introduced the FBBIKHeadEffector component that enables us to use the FullBodyBipedIK component to map a character to the target position and rotation of the head. <br />
Please take a look at the "Head Effector" demo scene to see how it can be set up. <br />
This is useful in particular for VR developers. You can download the Oculus VR demo scenes for Final IK for <a href="http://www.root-motion.com/addons/FinalIK_OVR.unitypackage">Unity4</a> and <a href="http://www.root-motion.com/addons/FinalIK_OVR_Unity5.unitypackage">Unity5</a>.</p>
<p><b>Optimizing FullBodyBipedIK:</b></p><ul>
<li>You can use renderer.isVisible to weigh out the solver when the character is not visible.</li>
<li>Most of the time you don't need so many solver iterations and spine mapping iterations. Sine FinalIK 0.4, we are able to set solver iteration count to 0, in which case the full body effect will not be solved. This allows for easy optimization of IK on characters in the distance.</li>
<li>Keep the "Reach" values at 0 if you don't need them. By default they are 0.05f to improve accuracy.</li>
<li>Keep the Spine Twist Weight at 0 if you don't see the need for it.</li>
<li>Also setting the "Spine Stiffness", "Pull Body Vertical" and/or "Pull Body Horizontal" to 0 will slightly help the performance.</li>
<li>You don't need all the spine bones in the spine array. FBBIK works the fastest if there are 2 bones in the spine, the first one listed as the Root Node, and the other one the last bone in the spine (the last common ancestor of both arms). Having less bones in the Spine makes it more rigid, which in some cases might be even a better, more natural looking solution.</li>
</ul>
<p><b>Component variables:</b></p><ul>
<li><b>timeStep</b> - if zero, will update the solver in every LateUpdate(). Use this for chains that are animated. If &gt; 0, will be used as updating frequency so that the solver will reach its target in the same time on all machines</li>
<li><b>fixTransforms</b> - if true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance</li>
<li><b>references</b> - references to the character bones that FullBodyBipedIK needs to build it's solver. The eyes are not necessary.</li>
</ul>
<p><b>Solver variables:</b></p><ul>
<li><b>rootNode</b> - the central bone in the body. 2 triangles should be visible in the Scene view, the chest and the hips, connected by the rootNode.</li>
<li><b>weight</b> - the solver weight for smoothly blending out the effect of the IK</li>
<li><b>iterations</b> - the solver iteration count. If 0, full body effect will not be calculated. This allows for very easy optimization of IK on character in the distance.</li>
</ul>
<p><b>Body variables:</b></p><ul>
<li><b>Target</b> - the target Transform of the body effector. If assigned, solver.bodyEffector.position will be automatically set to the position of the target.</li>
<li><b>Position Weight</b> - the position weight of the body effector. If weighed in, the body will be pinned to solver.bodyEffector.position. This overrides bodyEffector.positionOffset.</li>
<li><b>Use Thighs</b> - if true, any effect on the body effector will be also applied to the thigh effectors. This makes it easier to move the lower body around.</li>
<li><b>Spine Stiffness</b> - the stiffness of spine constraints. Lower values "crack" the spine.</li>
<li><b>Pull Body Vertical</b> - weight of hand effectors pulling the body vertically (relative to root rotation).</li>
<li><b>Pull Body Horizontal</b> - weight of hand effectors pulling the body horizontally (relative to root rotation).</li>
<li><b>Spine Iterations</b> - the number of iterations of the FABRIK algorithm. Not used if there are 2 bones assigned to Spine in the References.</li>
<li><b>Spine Twist Weight</b> - the weight of twisting the spine bones gradually to the orientation of the chest triangle. Relatively expensive, so set this to 0 if there is not much spine twisting going on.</li>
<li><b>Maintain Head Rot</b> - if 1, the head will be rotated back to where it was (in world space) before solving FBBIK.</li>
</ul>
<p><b>Limb variables:</b></p><ul>
<li><b>Target</b> - the target Transform of the effector. If assigned, effector.position will be automatically set to the position of the target.</li>
<li><b>Position Weight</b> - the position weight of the effector. If weighed in, the effector bone will be pinned to effector.position. This overrides effector.positionOffset.</li>
<li><b>Rotation Weight</b> - the rotation weight of the effector. If weighed in, the limb will be rotated to effector.rotation. This also changes the bending direction of the limb. If the bending direction assumed by the solver is disagreeable, set rotation weight to 0 and either just rotate the hand/foot after FBBIK is done or use a Bend Goal for full precision.</li>
<li><b>Maintain Relative Pos</b> - if 1, the (unweighed) limb will rotate along with the chest/hip triangle.</li>
<li><b>Pull</b> - the weight of pulling the parent chain. If this limb is the only one to have full pull and the others have none, you will be able to pull the character from that end effector without ever loosing contact.</li>
<li><b>Reach</b> - pulls the first bone of the limb closer to the last bone.</li>
<li><b>Push</b> - the weight of the end-effector pushing the shoulder/thigh when the end-effector is close to it.</li>
<li><b>Push Parent</b> - the amount of push force transferred to the parent (from hand or foot to the body).</li>
<li><b>Reach Smoothing</b> - smoothing the effect of the Reach with the expense of some accuracy.</li>
<li><b>Push Smoothing</b> - smoothing the effect of the Push and Push Parent with the expense of some accuracy.</li>
<li><b>Bend Goal</b> - if assigned, will bend the limb to the direction from the shoulder/thigh to the Bend Goal.</li>
<li><b>Bend Goal Weight</b> - the weight of bending the limb towards the Bend Goal.</li>
<li><b>Mapping Weight</b> - if 0, the limb will not be mapped, meaning the bones of the limb will not be rotated at all even if the effectors are weighed in.</li>
<li><b>Maintain Hand/Foot Rot</b> - if 1, will rotate the hand/foot back to where it was (in world space) before solving FBBIK. This is usually useful for keeping the feet aligned to the surface when changing the position of the body or the height of the feet.</li>
</ul>
<div class="image">
<img src="FullBodyBipedIKComponent.png" alt="FullBodyBipedIKComponent.png"/>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
