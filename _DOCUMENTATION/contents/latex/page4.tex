Forward and Backward Reaching Inverse Kinematics solver based on the paper\+: ~\newline
\href{http://andreasaristidou.com/publications/FABRIK.pdf}{\tt \char`\"{}\+F\+A\+B\+R\+I\+K\+: A fast, iterative solver for the inverse kinematics problem.\char`\"{} } ~\newline
Aristidou, A., Lasenby, J. Department of Engineering, University of Cambridge, Cambridge C\+B2 1\+PZ, UK.

F\+A\+B\+R\+IK is a heuristic solver that can be used with any number of bone segments and rotation limits. It is a method based on forward and backward iterative movements by finding a joint\textquotesingle{}s new position along a line to the next joint. F\+A\+B\+R\+IK proposes to solve the IK problem in position space, instead of the orientation space, therefore it demonstrates less continuity under orientation constraints than C\+CD, although certain modifications have been made to the constraining method described in the original paper to improve solver stability. It generally takes less iterations to reach the target than C\+CD, but is slower per iteration especially with rotation limits applied.

F\+A\+B\+R\+IK is extremely flexible, it even allows for direct manipulation of the bone segments in the scene view and the solver will readapt. Bone lengths can also be changed in runtime. Monitoring and validating the IK chain each frame would be expensive on the performance, therefore changing the bone hierarchy in runtime has to be done by calling Set\+Chain (Transform\mbox{[}\mbox{]} hierarchy) on the solver. Set\+Chain returns true if the hierarchy is valid.

{\bfseries Getting started\+:}
\begin{DoxyItemize}
\item Add the F\+A\+B\+R\+IK component to the first Game\+Object in the chain
\item Assign all the elements in the chain to \char`\"{}\+Bones\char`\"{} in the component
\item Press Play, set weight to 1
\end{DoxyItemize}

{\bfseries Changing the target position\+:}


\begin{DoxyCode}
\textcolor{keyword}{public} FABRIK fabrik;

\textcolor{keywordtype}{void} LateUpdate () \{
    fabrik.solver.IKPosition = something;
\}
\end{DoxyCode}


{\bfseries Adding F\+A\+B\+R\+IK in runtime\+:}
\begin{DoxyItemize}
\item Add the F\+A\+B\+R\+IK component via script
\item Call F\+A\+B\+R\+I\+K.\+solver.\+Set\+Chain()
\end{DoxyItemize}

{\bfseries Using F\+A\+B\+R\+IK with Rotation Limits\+:} ~\newline
Simply add a Rotation Limit component (Rotation\+Limit\+Angle, Rotation\+Limit\+Hinge, Rotation\+Limit\+Polygonal or Rotation\+Limit\+Spline) to a bone that has been assigned to the \char`\"{}\+Bones\char`\"{} of the F\+A\+B\+R\+IK component. Note that each rotation limit decreases the stability and continuity of the solver. If F\+A\+B\+R\+IK is unable to solve a highly constrained chain at certain target positions, it is most likely not a bug with Final\+IK, but a fundamental handicap of the F\+A\+B\+R\+IK algorithm (remember, no IK algorithm is perfect).



{\bfseries Component variables\+:}
\begin{DoxyItemize}
\item {\bfseries time\+Step} -\/ if zero, will update the solver in every Late\+Update(). Use this for chains that are animated. If $>$ 0, will be used as updating frequency so that the solver will reach its target in the same time on all machines
\item {\bfseries fix\+Transforms} -\/ if true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance
\end{DoxyItemize}

{\bfseries Solver variables\+:}
\begin{DoxyItemize}
\item {\bfseries target} -\/ the target Transform. If assigned, solver I\+K\+Position will be automatically set to the position of the target.
\item {\bfseries weight} -\/ the solver weight for smoothly blending out the effect of the IK
\item {\bfseries tolerance} -\/ minimum distance from last reached position. Will stop solving if difference from previous reached position is less than tolerance. If tolerance is zero, will iterate until max\+Iterations.
\item {\bfseries max\+Iterations} -\/ max iterations per frame. If tolerance is 0, will always iterate until max\+Iterations
\item {\bfseries use\+Rotation\+Limits} -\/ if true, will use any Rotation\+Limit component attached to the bones
\item {\bfseries bones} -\/ bones used by the solver to reach to the target. All bones need to be sorted in descending order (parents first). Bones can be skipped in the hierarchy. The bone hierarchy can not be branched, meaning you cant assing bones from both hands. Bone weight determines how strongly it is used by the solver.
\end{DoxyItemize}

 