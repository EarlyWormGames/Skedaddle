The IK solvers and rotation limits of Final\+IK were built from the ground up with extendability in mind. ~\newline
Some of the components of Final\+IK, such as Biped\+IK, are essentially little more than just collections of IK solvers.\hypertarget{page13_customcomponents}{}\section{Writing Custom I\+K Components}\label{page13_customcomponents}
Before you can exploit the full power of Final\+IK, it is important to know a few things about it\textquotesingle{}s architecture.

{\bfseries The difference between IK components and IK solvers\+:} ~\newline
 By architecture, IK solver is a class that actually contains the inverse kinematics functionality, while the function of an IK component is only to harbor, initiate and update it\textquotesingle{}s solver and provide helpful scene view handles as well as custom inspectors. ~\newline
 ~\newline
 Therefore, IK solvers are fully independent of their components and can even be used without them through direct reference\+:


\begin{DoxyCode}
\textcolor{keyword}{using} \mbox{\hyperlink{namespace_root_motion}{RootMotion}}.\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k}{FinalIK}};

\textcolor{keyword}{public} IKSolverCCD spine = \textcolor{keyword}{new} IKSolverCCD();
\textcolor{keyword}{public} IKSolverLimb limb = \textcolor{keyword}{new} IKSolverLimb();

\textcolor{keywordtype}{void} Start() \{
    \textcolor{comment}{// The root transform reference is used in the initiation of IK solvers for multiple reasons depending
       on the solver.}
    \textcolor{comment}{// heuristic solvers IKSolverCCD, IKSolverFABRIK and IKSolverAim only need it as context for logging
       warnings, }
    \textcolor{comment}{// character solvers IKSolverLimb, IKSolverLookAt, BipedIK and IKSolverFullBodyBiped use it to define
       their orientation relative to the character,}
    \textcolor{comment}{// IKSolverFABRIKRoot uses it as the root of all of it's FABRIK chains.}
    spine.Initiate(transform);
    limb.Initiate(transform);
\}

\textcolor{keywordtype}{void} LateUpdate() \{
    \textcolor{comment}{// Updating the IK solvers in a specific order.}
    \textcolor{comment}{// In the case of multiple IK solvers handling a bone hierarchy, it is usually wise to solve the
       parents first.}
    spine.Update();
    limb.Update();
\}
\end{DoxyCode}
 You now have essentially a custom IK component. ~\newline
This can be helpful if you needed to keep all the functionality of your IK system in a single component, like Biped\+IK, so you would not have to manage many different IK components in your scene.\hypertarget{page13_customrotationlimits}{}\section{Writing Custom Rotation Limits}\label{page13_customrotationlimits}
All rotation limits in Final IK extend from the abstract Rotation\+Limit class. To compose your own, you would as well need to extend from this base class and override the abstract method 
\begin{DoxyCode}
\textcolor{keyword}{protected} \textcolor{keyword}{abstract} Quaternion LimitRotation(Quaternion rotation); 
\end{DoxyCode}


In this method you will have to apply the constraint to and return the input Quaternion. ~\newline
It is important to note that the input Quaternion is already converted to the default local rotation space of the gameobject, meaning if you return Quaternion.\+identity, the gameobject will always remain fixed to it\textquotesingle{}s initial local rotation.

The following code could be a template for a custom rotation limit\+:


\begin{DoxyCode}
\textcolor{keyword}{using} \mbox{\hyperlink{namespace_root_motion}{RootMotion}}.\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k}{FinalIK}};

\textcolor{comment}{// Declaring the class and extending from RotationLimit.cs}
\textcolor{keyword}{public} \textcolor{keyword}{class }RotationLimitCustom: RotationLimit \{
    
    \textcolor{comment}{// Limits the rotation in the local space of this instance's Transform.}
    \textcolor{keyword}{protected} \textcolor{keyword}{override} Quaternion LimitRotation(Quaternion rotation) \{      
        \textcolor{keywordflow}{return} MyLimitFunction(rotation);
    \}

\}
\end{DoxyCode}
 The new rotation limit gets recognized and applied automatically by all constrainable IK solvers.\hypertarget{page13_combining}{}\section{Combining I\+K Components}\label{page13_combining}
When creating more complex IK systems, you will probably need full control over the updating order of your solvers. To do that, you can just disable their components and manage their solvers from an external script. ~\newline
All IK components extend from the abstract IK class and all IK solvers extend from the abstract I\+K\+Solver class. This enables you to easily handle or replace the solvers even without needing to know the specific type of the solver. ~\newline
Controlling the updating order of multiple IK components\+: 
\begin{DoxyCode}
\textcolor{keyword}{using} \mbox{\hyperlink{namespace_root_motion}{RootMotion}}.\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k}{FinalIK}};

\textcolor{comment}{// Array of IK components that you can assign from the inspector. }
\textcolor{comment}{// IK is abstract, so it does not matter which specific IK component types are used.}
\textcolor{keyword}{public} IK[] components;
    
\textcolor{keywordtype}{void} Start() \{
    \textcolor{comment}{// Disable all the IK components so they won't update their solvers. Use Disable() instead of enabled =
       false, the latter does not guarantee solver initiation.}
    \textcolor{keywordflow}{foreach} (IK component \textcolor{keywordflow}{in} components) component.Disable();
\}

\textcolor{keywordtype}{void} LateUpdate() \{
    \textcolor{comment}{// Updating the IK solvers in a specific order. }
    \textcolor{keywordflow}{foreach} (IK component \textcolor{keywordflow}{in} components) component.GetIKSolver().Update();
\}
\end{DoxyCode}


{\bfseries Animate Physics} ~\newline
When your character has Animate Physics checked (Update\+Mode.\+Animate\+Physics since Unity 4.\+5), you will need to check if a Fixed\+Update has been called before updating the IK solvers in Late\+Update. Otherwise the IK solvers will be updated multiple times before the Animator/\+Animation overwrites the pose and accumulate resulting in a high frequency flicker. So the way to update the solvers with Animate Physics would be like this;


\begin{DoxyCode}
\textcolor{keyword}{using} \mbox{\hyperlink{namespace_root_motion}{RootMotion}}.\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k}{FinalIK}};

\textcolor{comment}{// Array of IK components that you can assign from the inspector. }
\textcolor{comment}{// IK is abstract, so it does not matter which specific IK component types are used.}
\textcolor{keyword}{public} IK[] components;

\textcolor{keyword}{private} \textcolor{keywordtype}{bool} updateFrame;
    
\textcolor{keywordtype}{void} Start() \{
    \textcolor{comment}{// Disable all the IK components so they won't update their solvers. Use Disable() instead of enabled =
       false, the latter does not guarantee solver initiation.}
    \textcolor{keywordflow}{foreach} (IK component \textcolor{keywordflow}{in} components) component.Disable();
\}

\textcolor{keywordtype}{void} FixedUpdate() \{
    updateFrame = \textcolor{keyword}{true};
\}

\textcolor{keywordtype}{void} LateUpdate() \{
    \textcolor{comment}{// Do nothing if FixedUpdate has not been called since the last LateUpdate}
    \textcolor{keywordflow}{if} (!updateFrame) \textcolor{keywordflow}{return};
    updateFrame = \textcolor{keyword}{false};
    
    \textcolor{comment}{// Updating the IK solvers in a specific order. }
    \textcolor{keywordflow}{foreach} (IK component \textcolor{keywordflow}{in} components) component.GetIKSolver().Update();
\}
\end{DoxyCode}
 