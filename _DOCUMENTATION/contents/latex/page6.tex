Final IK includes an extremely flexible and powerful high speed lightweight F\+B\+IK solver for biped characters.

Full\+Body\+Biped\+IK maps any biped character to a low resolution multi-\/effector IK rig, solves it, and maps the result back to the character. This is done each frame in Late\+Update, after Mecanim/\+Legacy is done animating, so it is completely independent from the animating system.

{\bfseries Chains\+:} Internally, each limb and the body are instances of the F\+B\+I\+K\+Chain class. The root chain is the body, consisting of a single node, and the limbs are it\textquotesingle{}s children. This setup forms the multi-\/effector IK tree around the root node.

{\bfseries Nodes\+:} Nodes are members of the Chains. For instance, an Arm chain contains three nodes -\/ upper arm, forearm and the hand. Each node maintains a reference to it\textquotesingle{}s bone (node.\+transform). When the solver is processing or has finished, the solved position of the bone is stored in node.\+solver\+Position.

{\bfseries Effectors\+:} Full\+Body\+Biped\+IK has three types of effectors -\/ end-\/effectors (hands and feet), mid-\/body effectors (shoulders and thighs) and multi-\/effectors (the body). End-\/effectors can be rotated while changing the rotation of mid-\/body and multi-\/effectors has no effect. Changing end-\/effector rotation also changes the bending direction of the limb (unless you are using bend goals to override it). The body effector is a multi-\/effector, meaning it also drags along both thigh effectors (to simplify positioning of the body). Effectors also have the position\+Offset property that can be used to very easily manupulate with the underlaying animation. Effectors will reset their position\+Offset to Vector3.\+zero after each solver update.

{\bfseries Pulling, Reaching and Pushing\+:} Each chain has the \char`\"{}pull\char`\"{} property. When all chains have pull equal to 1, pull weight is distributed equally between the limbs. That means reaching all effectors is not quaranteed if they are very far from each other. The result can be adjusted or improved by changing the \char`\"{}reach\char`\"{} parameter of the chain, increasing the solver iteration count or updating the solver more than once per frame. However, when for instance the left arm chain has pull weight equal to 1 and all others have 0, you can pull the character from it\textquotesingle{}s left hand to Infinity without losing contact. The Push and Push Parent values determine how much a limb transfers energy to it\textquotesingle{}s parent nodes when the target is in reach. Experiment with those values in the Scene view to get a better understanding of how they behave.

{\bfseries Mapping\+:} I\+K\+Solver\+Full\+Body\+Biped solves a very low resolution high speed armature. Your character probably has a lot more bones in it\textquotesingle{}s spine though, it might have twist bones in the arms and shoulder or hip bones and so on. Therefore, the solver needs to map the high resolution skeleton to the low resolution solver skeleton before solving and vice versa after the solver has finished. There are 3 types of mappers -\/ I\+K\+Mapping\+Spine for mapping the pelvis and the spine, I\+K\+Mapping\+Limb for the limbs (including the clavicle) and I\+K\+Mapping\+Bone for the head. You can access them through I\+K\+Solver\+Full\+Body.\+spine\+Mapping, I\+K\+Solver\+Full\+Body.\+limb\+Mappings and I\+K\+Solver\+Full\+Body.\+bone\+Mappings

 {\bfseries Limitations\+:}
\begin{DoxyItemize}
\item Full\+Body\+Biped\+IK does not have effectors for the fingers and toes. Solving fingers with IK would be an overkill in most cases as there are only so few poses for the hands in a game. Using 10 4-\/segment constrained C\+CD or F\+A\+B\+R\+IK chains to position the fingers however is probably something you don\textquotesingle{}t want to waste your precious milliseconds on. See the Driving Rig demo to get an idea how to very quickly (and entirely in Unity) pose the fingers to an object.
\item Full\+Body\+Biped\+IK samples the initial pose of your character (in Start() and each time you re-\/initiate the solver) to find out which way the limbs should be bent. Hence the limitation -\/ the limbs of the character at that moment should be bent in their natural directions. Some characters however are in geometrically perfect T-\/\+Pose, meaning their limbs are completely straight. Some characters even have their limbs bent slightly in the inverse direction (some Mixamo rigs for example). Full\+Body\+Biped\+IK will alarm you should this problem occur. All you will have to do, is rotate the forearm or calf bones in the Scene view slightly in the direction they should be bent. Since those rotations will be overwritten in play mode by animation anyway, you should not be afraid of messing up your character.
\item Full\+Body\+Biped\+IK does not have elbow/knee effectors. That might change in the future should there be a practical demand for them. Elbow and knee positions can still be modified though as bend goals are supported.
\item Optimize Game Objects should be disabled or at least all the bones needed by the solver (Full\+Body\+Biped\+I\+K.\+references) exposed.
\item Additional bones in the limbs are supported as long as their animation is twisting only. If the additional bones have swing animation, like for example wing bones, F\+B\+B\+IK will not solve the limb correctly.
\item Full\+Body\+Biped\+IK does not rotate the shoulder bone when the character is pulled by the hand. It will maintain the shoulder bone rotation relative to the chest as it is in the animation. In most cases, it is not a problem, but sometimes, especially when reaching for something above the head, having the shoulder bone rotate along would make it more realistic. In this case you should either have an underlaying reach up (procedural) animation that rotates the shoulder bone or it can also be rotated via script before the IK solver reads the character\textquotesingle{}s pose. There is also a workaround script included in the demos, called Shoulder\+Rotator, just add it to the F\+B\+B\+IK game object.
\item When you move a limb end-\/effector and the effector rotation weight is 0, F\+B\+B\+IK will try to maintain the bending direction of the limb as it is animated. When the limb rotates close to 180 degrees from it\textquotesingle{}s animated direction, you will start experiencing rolling of the limb, meaning, the solver has no way to know at this point of singularity, which way to rotate the limb. Therefore if you for example have a walking animation, where the hands are down and you want to use IK to grab something from directly above the head, you will have to take the inconvenience to also animate the effector rotation or use a bend goal, to make sure the arm does not roll backwards when close to 180 degrees of angular offset. This is not a bug, it is a logical inevitability if we want to maintain the animated bending direction by default.
\item Full\+Body\+Biped\+IK considers all elbows and knees as 3 D\+OF joints with swing rotation constrained to the range of a hemisphere (Since 0.\+22, used to be 1 D\+OF). That allows for full accuracy mapping of all biped rigs, the only known limitation is that the limbs can\textquotesingle{}t be inverted (broken from the knee/elbow).
\end{DoxyItemize}

{\bfseries Getting started\+:}
\begin{DoxyItemize}
\item Add the Full\+Body\+Biped\+IK component to the root of your character (the same Game\+Object that has the Animator/\+Animation component)
\item Make sure the auto-\/detected biped references are correct
\item Make sure the Root Node was correctly detected. It should be one of the bones in the lower spine.
\item Take a look at the character in the scene view, make sure you see the Full\+Body\+Biped\+IK armature on top the character.
\item Press Play, weigh in the effectors
\end{DoxyItemize}

{\bfseries Accessing the Effectors\+:}


\begin{DoxyCode}
\textcolor{keyword}{public} FullBodyBipedIK ik;

\textcolor{keywordtype}{void} LateUpdate () \{
    ik.solver.leftHandEffector.position = something; \textcolor{comment}{// Set the left hand effector position to a point in
       world space. This has no effect if the effector's positionWeight is 0.}
    ik.solver.leftHandEffector.rotation = something; \textcolor{comment}{// Set the left hand effector rotation to a point in
       world space. This has no effect if the effector's rotationWeight is 0.}
    ik.solver.leftHandEffector.positionWeight = 1f; \textcolor{comment}{// Weighing in the effector position, the left hand
       will be pinned to ik.solver.leftHandEffector.position.}

    \textcolor{comment}{// Weighing in the effector rotation, the left hand and the arm will be pinned to
       ik.solver.leftHandEffector.rotation.}
    \textcolor{comment}{// Note that if you only wanted to rotate the hand, but not change the arm bending, }
    \textcolor{comment}{// it is better to just rotate the hand bone after FBBIK has finished updating (use the OnPostUpdate
       delegate).}
    ik.solver.leftHandEffector.rotationWeight = 1f;

    \textcolor{comment}{// Offsets the hand from it's animated position. If effector positionWeight is 1, this has no effect.}
    \textcolor{comment}{// Note that the effectors will reset their positionOffset to Vector3.zero after each update, so you
       can (and should) use them additively. }
    \textcolor{comment}{//This enables you to easily edit the value by more than one script.}
    ik.solver.leftHandEffector.positionOffset += something; 
    
    \textcolor{comment}{//The effector mode is for changing the way the limb behaves when not weighed in.}
    \textcolor{comment}{//Free means the node is completely at the mercy of the solver. }
    \textcolor{comment}{//(If you have problems with smoothness, try changing the effector mode of the hands to
       MaintainAnimatedPosition or MaintainRelativePosition}

    \textcolor{comment}{//MaintainAnimatedPosition resets the node to the bone's animated position in each internal solver
       iteration. }
    \textcolor{comment}{//This is most useful for the feet, because normally you need them where they are animated.}

    \textcolor{comment}{//MaintainRelativePositionWeight maintains the limb's position relative to the chest for the arms and
       hips for the legs. }
    \textcolor{comment}{// So if you pull the character from the left hand, the right arm will rotate along with the chest.}
    \textcolor{comment}{//Normally you would not want to use this behaviour for the legs.}
    ik.solver.leftHandEffector.maintainRelativePositionWeight = 1f;

    \textcolor{comment}{// The body effector is a multi-effector, meaning it also manipulates with other nodes in the solver,
       namely the left thigh and the right thigh}
    \textcolor{comment}{// so you could move the body effector around and the thigh bones with it. If we set effectChildNodes
       to false, the thigh nodes will not be changed by the body effector.}
    ik.solver.body.effectChildNodes = \textcolor{keyword}{false};

    \textcolor{comment}{// Other effectors: rightHandEffector, leftFootEffector, rightFootEffector, leftShoulderEffector,
       rightShoulderEffector, leftThighEffector, rightThighEffector, bodyEffector}

    \textcolor{comment}{// You can also find an effector by:}
    ik.solver.GetEffector(\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k_ae0dd2058c7667b6f132c11a6b860c14a}{FullBodyBipedEffector}} effectorType);
    ik.solver.GetEffector(\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k_ae8848c0353270a08dcfe8b85a5c9b761}{FullBodyBipedChain}} chainType);
    ik.solver.GetEndEffector(\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k_ae8848c0353270a08dcfe8b85a5c9b761}{FullBodyBipedChain}} chainType); \textcolor{comment}{// Returns only hand or feet
       effectors}
\}
\end{DoxyCode}


{\bfseries Accessing the Chains\+:}


\begin{DoxyCode}
\textcolor{keyword}{public} FullBodyBipedIK ik;

\textcolor{keywordtype}{void} LateUpdate () \{
    ik.solver.leftArmChain.pull = 1f; \textcolor{comment}{// Changing the Pull value of the left arm}
    ik.solver.leftArmChain.reach = 0f; \textcolor{comment}{// Changing the Reach value of the left arm}

    \textcolor{comment}{// Other chains: rightArmChain, leftLegChain, rightLegChain, chain (the root chain)}

    \textcolor{comment}{// You can also find a chain by:}
    ik.solver.GetChain(\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k_ae8848c0353270a08dcfe8b85a5c9b761}{FullBodyBipedChain}} chainType);
    ik.solver.GetChain(\mbox{\hyperlink{namespace_root_motion_1_1_final_i_k_ae0dd2058c7667b6f132c11a6b860c14a}{FullBodyBipedEffector}} effectorType);
\}
\end{DoxyCode}


{\bfseries Accessing the Mapping\+:}


\begin{DoxyCode}
\textcolor{keyword}{public} FullBodyBipedIK ik;

\textcolor{keywordtype}{void} LateUpdate () \{
    ik.solver.spineMapping.iterations = 2; \textcolor{comment}{// Changing the Spine Mapping Iterations}
    ik.solver.leftArmMapping.maintainRotationWeight = 1f; \textcolor{comment}{// Make the left hand maintain it's rotation as
       animated.}
    ik.solver.headMapping.maintainRotationWeight = 1f; \textcolor{comment}{// Make the head maintain it's rotation as animated.}
\}
\end{DoxyCode}


{\bfseries Adding Full\+Body\+Biped\+IK in runtime (U\+MA)\+:} 
\begin{DoxyCode}
\textcolor{keyword}{using} \mbox{\hyperlink{namespace_root_motion}{RootMotion}}; \textcolor{comment}{// Need to include the RootMotion namespace as well because of the
       BipedReferences}

FullBodyBipedIK ik;

\textcolor{comment}{// Call this method whenever you need in runtime. }
\textcolor{comment}{// Please note that FBBIK will sample the pose of the character at initiation so at the time of calling
       this method,}
\textcolor{comment}{// the limbs of the character should be bent in their natural directions.}
\textcolor{keywordtype}{void} AddFBBIK (GameObject go, BipedReferences references = null) \{

    \textcolor{keywordflow}{if} (references == null) \{ \textcolor{comment}{// Auto-detect the biped definition if we don't have it yet}
        BipedReferences.AutoDetectReferences(ref references, go.transform, BipedReferences.AutoDetectParams
      .Default);
    \}

    ik = go.AddComponent<FullBodyBipedIK>(); \textcolor{comment}{// Adding the component}

    \textcolor{comment}{// Set the FBBIK to the references. You can leave the second parameter (root node) to null if you trust
       FBBIK to automatically set it to one of the bones in the spine.}
    ik.SetReferences(references, null);

    \textcolor{comment}{// Using pre-defined limb orientations to safeguard from possible pose sampling problems (since 0.22)}
    ik.solver.SetLimbOrientations(BipedLimbOrientations.UMA); \textcolor{comment}{// The limb orientations definition for UMA
       skeletons}
    \textcolor{comment}{// or...}
    ik.solver.SetLimbOrientations(BipedLimbOrientations.MaxBiped); \textcolor{comment}{// The limb orientations definition for
       3ds Max Biped skeletons}
    \textcolor{comment}{// or..}
    ik.solver.SetLimbOrientations(yourCustomBipedLimbOrientations); \textcolor{comment}{// Your custom limb orientations
       definition}

    \textcolor{comment}{// To know how to fill in the custom limb orientations definition, you should imagine your character
       standing in I-pose (not T-pose) with legs together and hands on the sides...}
    \textcolor{comment}{// The Upper Bone Forward Axis is the local axis of the thigh/upper arm bone that is facing towards
       character forward.}
    \textcolor{comment}{// Lower Bone Forward Axis is the local axis of the calf/forearm bone that is facing towards character
       forward.}
    \textcolor{comment}{// Last Bone Left Axis is the local axis of the foot/hand that is facing towards character left.}
\}
\end{DoxyCode}


{\bfseries Solving the head} ~\newline
 Final IK 0.\+5 introduced the F\+B\+B\+I\+K\+Head\+Effector component that enables us to use the Full\+Body\+Biped\+IK component to map a character to the target position and rotation of the head. ~\newline
Please take a look at the \char`\"{}\+Head Effector\char`\"{} demo scene to see how it can be set up. ~\newline
This is useful in particular for VR developers. You can download the Oculus VR demo scenes for Final IK for \href{http://www.root-motion.com/addons/FinalIK_OVR.unitypackage}{\tt Unity4} and \href{http://www.root-motion.com/addons/FinalIK_OVR_Unity5.unitypackage}{\tt Unity5}.

{\bfseries Optimizing Full\+Body\+Biped\+IK\+:}
\begin{DoxyItemize}
\item You can use renderer.\+is\+Visible to weigh out the solver when the character is not visible.
\item Most of the time you don\textquotesingle{}t need so many solver iterations and spine mapping iterations. Sine Final\+IK 0.\+4, we are able to set solver iteration count to 0, in which case the full body effect will not be solved. This allows for easy optimization of IK on characters in the distance.
\item Keep the \char`\"{}\+Reach\char`\"{} values at 0 if you don\textquotesingle{}t need them. By default they are 0.\+05f to improve accuracy.
\item Keep the Spine Twist Weight at 0 if you don\textquotesingle{}t see the need for it.
\item Also setting the \char`\"{}\+Spine Stiffness\char`\"{}, \char`\"{}\+Pull Body Vertical\char`\"{} and/or \char`\"{}\+Pull Body Horizontal\char`\"{} to 0 will slightly help the performance.
\item You don\textquotesingle{}t need all the spine bones in the spine array. F\+B\+B\+IK works the fastest if there are 2 bones in the spine, the first one listed as the Root Node, and the other one the last bone in the spine (the last common ancestor of both arms). Having less bones in the Spine makes it more rigid, which in some cases might be even a better, more natural looking solution.
\end{DoxyItemize}

{\bfseries Component variables\+:}
\begin{DoxyItemize}
\item {\bfseries time\+Step} -\/ if zero, will update the solver in every Late\+Update(). Use this for chains that are animated. If $>$ 0, will be used as updating frequency so that the solver will reach its target in the same time on all machines
\item {\bfseries fix\+Transforms} -\/ if true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance
\item {\bfseries references} -\/ references to the character bones that Full\+Body\+Biped\+IK needs to build it\textquotesingle{}s solver. The eyes are not necessary.
\end{DoxyItemize}

{\bfseries Solver variables\+:}
\begin{DoxyItemize}
\item {\bfseries root\+Node} -\/ the central bone in the body. 2 triangles should be visible in the Scene view, the chest and the hips, connected by the root\+Node.
\item {\bfseries weight} -\/ the solver weight for smoothly blending out the effect of the IK
\item {\bfseries iterations} -\/ the solver iteration count. If 0, full body effect will not be calculated. This allows for very easy optimization of IK on character in the distance.
\end{DoxyItemize}

{\bfseries Body variables\+:}
\begin{DoxyItemize}
\item {\bfseries Target} -\/ the target Transform of the body effector. If assigned, solver.\+body\+Effector.\+position will be automatically set to the position of the target.
\item {\bfseries Position Weight} -\/ the position weight of the body effector. If weighed in, the body will be pinned to solver.\+body\+Effector.\+position. This overrides body\+Effector.\+position\+Offset.
\item {\bfseries Use Thighs} -\/ if true, any effect on the body effector will be also applied to the thigh effectors. This makes it easier to move the lower body around.
\item {\bfseries Spine Stiffness} -\/ the stiffness of spine constraints. Lower values \char`\"{}crack\char`\"{} the spine.
\item {\bfseries Pull Body Vertical} -\/ weight of hand effectors pulling the body vertically (relative to root rotation).
\item {\bfseries Pull Body Horizontal} -\/ weight of hand effectors pulling the body horizontally (relative to root rotation).
\item {\bfseries Spine Iterations} -\/ the number of iterations of the F\+A\+B\+R\+IK algorithm. Not used if there are 2 bones assigned to Spine in the References.
\item {\bfseries Spine Twist Weight} -\/ the weight of twisting the spine bones gradually to the orientation of the chest triangle. Relatively expensive, so set this to 0 if there is not much spine twisting going on.
\item {\bfseries Maintain Head Rot} -\/ if 1, the head will be rotated back to where it was (in world space) before solving F\+B\+B\+IK.
\end{DoxyItemize}

{\bfseries Limb variables\+:}
\begin{DoxyItemize}
\item {\bfseries Target} -\/ the target Transform of the effector. If assigned, effector.\+position will be automatically set to the position of the target.
\item {\bfseries Position Weight} -\/ the position weight of the effector. If weighed in, the effector bone will be pinned to effector.\+position. This overrides effector.\+position\+Offset.
\item {\bfseries Rotation Weight} -\/ the rotation weight of the effector. If weighed in, the limb will be rotated to effector.\+rotation. This also changes the bending direction of the limb. If the bending direction assumed by the solver is disagreeable, set rotation weight to 0 and either just rotate the hand/foot after F\+B\+B\+IK is done or use a Bend Goal for full precision.
\item {\bfseries Maintain Relative Pos} -\/ if 1, the (unweighed) limb will rotate along with the chest/hip triangle.
\item {\bfseries Pull} -\/ the weight of pulling the parent chain. If this limb is the only one to have full pull and the others have none, you will be able to pull the character from that end effector without ever loosing contact.
\item {\bfseries Reach} -\/ pulls the first bone of the limb closer to the last bone.
\item {\bfseries Push} -\/ the weight of the end-\/effector pushing the shoulder/thigh when the end-\/effector is close to it.
\item {\bfseries Push Parent} -\/ the amount of push force transferred to the parent (from hand or foot to the body).
\item {\bfseries Reach Smoothing} -\/ smoothing the effect of the Reach with the expense of some accuracy.
\item {\bfseries Push Smoothing} -\/ smoothing the effect of the Push and Push Parent with the expense of some accuracy.
\item {\bfseries Bend Goal} -\/ if assigned, will bend the limb to the direction from the shoulder/thigh to the Bend Goal.
\item {\bfseries Bend Goal Weight} -\/ the weight of bending the limb towards the Bend Goal.
\item {\bfseries Mapping Weight} -\/ if 0, the limb will not be mapped, meaning the bones of the limb will not be rotated at all even if the effectors are weighed in.
\item {\bfseries Maintain Hand/\+Foot Rot} -\/ if 1, will rotate the hand/foot back to where it was (in world space) before solving F\+B\+B\+IK. This is usually useful for keeping the feet aligned to the surface when changing the position of the body or the height of the feet.
\end{DoxyItemize}

 